<!DOCTYPE html>
<html lang="fr">
<!--Begin of sqljob notebook -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iHateXcel - sqljob</title>
    <link href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator_simple.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-3.3.0.min.js"></script>
    <script>
        var duckdbLibraryVersion = '1.28.0';
        var duckDbLibraryUrl = `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${duckdbLibraryVersion}/+esm`;
    </script>
    <style>
        /* Light Mode (par d√©faut) */
        :root {
            --bg-primary: #f5f7fa;
            --bg-secondary: #ffffff;
            --bg-cell: #ffffff;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --shadow: rgba(0, 0, 0, 0.06);
            --overlay: rgba(0, 0, 0, 0.4);
            --accent-bg: rgba(99, 102, 241, 0.08);
            --success-bg: rgba(34, 197, 94, 0.08);
        }
        
        /* Dark Mode */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-cell: #1e293b;
            --accent: #818cf8;
            --accent-hover: #a5b4fc;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
            --shadow: rgba(0, 0, 0, 0.25);
            --overlay: rgba(0, 0, 0, 0.7);
            --accent-bg: rgba(129, 140, 248, 0.15);
            --success-bg: rgba(74, 222, 128, 0.15);
        }
        
        * { box-sizing: border-box; }
        
        /* Transition fluide pour le changement de th√®me */
        *, *::before, *::after {
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }
        
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            padding: 0; 
            margin: 0; 
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .app-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 4rem 1rem 2rem;
        }
        
        /* Header fixe */
        #fixedButtonsContainer {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px var(--shadow);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .header-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent);
        }
        
        .header-right {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .btn-header {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-cell);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }
        
        .btn-header:hover:not(:disabled) {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        .btn-header:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Lignes (rows) */
        .rows-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .row {
            display: flex;
            gap: 1rem;
            align-items: stretch;
            position: relative;
        }
        
        .row-cells {
            display: flex;
            gap: 1rem;
            flex: 1;
            min-width: 0;
        }
        
        .row-actions {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.5rem 0;
        }
        
        .btn-row-add {
            padding: 0.5rem;
            border: 2px dashed var(--border);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .btn-row-add:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--accent-bg);
        }
        
        /* Cellules */
        .cell {
            background: var(--bg-cell);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.2s, box-shadow 0.2s;
            flex: 1;
            min-width: 200px;
            box-shadow: 0 1px 3px var(--shadow);
        }
        
        .cell:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 12px var(--shadow);
        }
        
        .cell.running {
            border-color: var(--warning);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }
        
        .cell.success {
            border-color: var(--success);
        }
        
        .cell.error {
            border-color: var(--error);
        }
        
        .cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        
        .cell-type-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .cell-type-icon {
            font-size: 1rem;
        }
        
        .cell-actions {
            display: flex;
            gap: 0.25rem;
        }
        
        .btn-cell {
            padding: 0.35rem 0.5rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        
        .btn-cell:hover:not(:disabled) {
            background: var(--border);
            color: var(--text-primary);
        }
        
        .btn-cell:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .btn-cell.play:hover:not(:disabled) {
            color: var(--success);
        }
        
        .btn-cell.delete:hover:not(:disabled) {
            color: var(--error);
        }
        
        .cell-body {
            padding: 1rem;
        }
        
        /* Markdown Cell */
        .markdown-content {
            line-height: 1.6;
        }
        
        .markdown-content h1 { 
            font-size: 1.75rem; 
            margin: 0 0 0.5rem; 
            color: var(--accent);
        }
        
        .markdown-content h2 { 
            font-size: 1.4rem; 
            margin: 0.5rem 0; 
            color: var(--text-primary);
        }
        
        .markdown-content p { margin: 0.5rem 0; }
        .markdown-content code { 
            background: var(--bg-secondary); 
            padding: 0.2rem 0.4rem; 
            border-radius: 4px;
            font-family: 'Consolas', monospace;
        }
        
        /* Sources Cell */
        .sources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
        }
        
        .source-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            box-shadow: 0 1px 2px var(--shadow);
        }
        
        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .source-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .drop-zone {
            border: 2px dashed var(--border);
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            color: var(--text-secondary);
        }
        
        .drop-zone:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }
        
        .drop-zone.drag-over {
            border-color: var(--accent);
            background: var(--accent-bg);
        }
        
        .drop-zone.has-file {
            border-style: solid;
            border-color: var(--success);
            background: var(--success-bg);
        }
        
        .file-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-name {
            font-size: 0.9rem;
            color: var(--success);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .file-input { display: none; }
        
        /* SQL Cell */
        .sql-editor {
            width: 100%;
            min-height: 80px;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .sql-editor:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-bg);
        }
        
        /* Table Cell */
        .table-container {
            background: white;
            border-radius: 6px;
            overflow: hidden;
        }
        
        /* Plot Cell */
        .plot-container {
            background: white;
            border-radius: 6px;
            padding: 1rem;
            min-height: 300px;
        }
        
        /* Iframe Cell */
        .iframe-container iframe {
            width: 100%;
            min-height: 400px;
            border: none;
            border-radius: 6px;
            background: white;
        }
        
        /* S√©parateurs interactifs (entre lignes et cellules) */
        .row-separator {
            position: relative;
            height: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: -0.25rem 0;
            z-index: 10;
        }
        
        .row-separator::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: transparent;
            border-radius: 1px;
            transition: background 0.2s, width 0.2s;
        }
        
        .row-separator:hover::before {
            background: var(--accent);
            width: 80%;
        }
        
        .row-separator .separator-btn {
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--shadow);
            z-index: 11;
        }
        
        .row-separator:hover .separator-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .row-separator .separator-btn:hover {
            background: var(--accent-hover);
        }
        
        .cell-separator {
            position: relative;
            width: 1rem;
            min-width: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 0 -0.25rem;
            z-index: 10;
            align-self: stretch;
        }
        
        .cell-separator::before {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 60%;
            background: transparent;
            border-radius: 1px;
            transition: background 0.2s, height 0.2s;
        }
        
        .cell-separator:hover::before {
            background: var(--accent);
            height: 80%;
        }
        
        .cell-separator .separator-btn {
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--shadow);
            z-index: 11;
        }
        
        .cell-separator:hover .separator-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .cell-separator .separator-btn:hover {
            background: var(--accent-hover);
        }
        
        /* Add Row/Cell Button */
        .add-row-container {
            display: flex;
            justify-content: center;
            padding: 1rem;
        }
        
        .btn-add-row {
            padding: 0.75rem 1.5rem;
            border: 2px dashed var(--border);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }
        
        .btn-add-row:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .btn-add-cell {
            padding: 0.75rem 1.5rem;
            border: 2px dashed var(--border);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }
        
        .btn-add-cell:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Row header (dev mode) */
        .row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.5rem;
            background: var(--bg-secondary);
            border-radius: 6px 6px 0 0;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .row-header-actions {
            display: flex;
            gap: 0.25rem;
        }
        
        .btn-row {
            padding: 0.25rem 0.4rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .btn-row:hover:not(:disabled) {
            background: var(--border);
            color: var(--text-primary);
        }
        
        .btn-row:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--bg-cell);
            border: 1px solid var(--border);
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px -12px var(--shadow);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .modal-close:hover {
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .form-field {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .form-field label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .form-field input,
        .form-field textarea,
        .form-field select {
            padding: 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
        
        .form-field input:focus,
        .form-field textarea:focus,
        .form-field select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .form-field textarea {
            min-height: 100px;
            font-family: 'Consolas', monospace;
            resize: vertical;
        }
        
        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .btn-modal {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .btn-modal.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .btn-modal.secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        /* Bottom Left Controls */
        .bottom-controls {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 1500;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .control-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-cell);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .control-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
            color: var(--text-primary);
        }
        
        .control-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* Theme toggle specific */
        .theme-btn {
            font-size: 1rem;
            padding: 0.5rem 0.6rem;
        }
        
        /* DevMode Toggle (legacy class for compatibility) */
        .devmode-toggle {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 1500;
        }
        
        .devmode-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-cell);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .devmode-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
            color: var(--text-primary);
        }
        
        .devmode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        @media print {
            .bottom-controls,
            .devmode-toggle {
                display: none !important;
            }
        }
        
        /* Status */
        .status-bar {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 1500;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .status-bar.loading {
            background: var(--warning);
            color: #000;
        }
        
        .status-bar.success {
            background: var(--success);
            color: #000;
        }
        
        .status-bar.error {
            background: var(--error);
            color: white;
        }
        
        /* Cell result info */
        .cell-result-info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        /* Print styles */
        @media print {
            #fixedButtonsContainer, .cell-header, .add-cell-container, footer, .status-bar {
                display: none !important;
            }
            
            body {
                background: white;
                color: black;
            }
            
            .cell {
                border: none;
                box-shadow: none;
                page-break-inside: avoid;
            }
            
            .cell-body {
                padding: 0.5rem 0;
            }
            
            .plot-container, .table-container {
                box-shadow: none;
            }
        }
        
        /* Checkbox style */
        .checkbox-field {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .checkbox-field input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: var(--accent);
        }
        
        /* Dropdown Export */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: var(--bg-cell);
            border: 1px solid var(--border);
            border-radius: 6px;
            min-width: 150px;
            z-index: 1100;
            margin-top: 0.25rem;
            box-shadow: 0 4px 12px var(--shadow);
        }
        
        .dropdown.open .dropdown-content {
            display: block;
        }
        
        .dropdown-item {
            display: block;
            width: 100%;
            padding: 0.6rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-primary);
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        
        .dropdown-item:hover {
            background: var(--border);
        }
        
        .dropdown-item:first-child {
            border-radius: 6px 6px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 6px 6px;
        }
    </style>
    <script type="application/octet-stream" id="defaultConfigBase64">ewogICJqb2IiOiB7CiAgICAiYXV0b0V4ZWN1dGVXaXRob3V0U291cmNlcyI6IGZhbHNlLAogICAgInJvd3MiOiBbCiAgICAgIHsKICAgICAgICAic3R5bGUiOiAiIiwKICAgICAgICAiY2VsbHMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJ0eXBlIjogIm1hcmtkb3duIiwKICAgICAgICAgICAgImNvbnRlbnQiOiAiIyBzcWxKb2Ig4pqh8J+Su1xuIyMgSSBIYXRlIEV4Y2VsLCBzbyBJIGJ1aWx0IGEgc2ltcGxlLCBjbGllbnQtc2lkZSBTUUwgam9iIHJ1bm5lci4g8J+boO+4j1xu8J+TpSBMb2FkLCDwn5SEIHRyYW5zZm9ybSwgYW5kIPCfk4ogdmlzdWFsaXplIHlvdXIgZGF0YSBkaXJlY3RseSBpbiB0aGUgYnJvd3NlcuKAlG5vIHNldHVwLCBubyBmdXNzLiDwn5qAIgogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgewogICAgICAgICJzdHlsZSI6ICIiLAogICAgICAgICJjZWxscyI6IFsKICAgICAgICAgIHsKICAgICAgICAgICAgInR5cGUiOiAic291cmNlcyIsCiAgICAgICAgICAgICJhdXRvUnVuTmV4dENlbGxzIjogdHJ1ZSwKICAgICAgICAgICAgInNvdXJjZXMiOiBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgIm5hbWUiOiAic291cmNlMSIsCiAgICAgICAgICAgICAgICAiaW1wb3J0VGV4dCI6ICJHbGlzc2V6LWTDqXBvc2V6IHZvdHJlIGZpY2hpZXIgaWNpIiwKICAgICAgICAgICAgICAgICJxdWVyeSI6ICJDUkVBVEUgT1IgUkVQTEFDRSBUQUJMRSBzb3VyY2UxIEFTIFNFTEVDVCAqIEZST00gcmVhZF9jc3ZfYXV0bygne2ZpbGVOYW1lVXBsb2FkfScsIEFMTF9WQVJDSEFSPXRydWUsIEhFQURFUj10cnVlKSIsCiAgICAgICAgICAgICAgICAieGxzeCI6IHsKICAgICAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7CiAgICAgICAgICAgICAgICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAgICAgICAgICAgICAgICJyYXciOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICAiZGF0ZU5GIjogImRkL21tL3l5eXkiLAogICAgICAgICAgICAgICAgICAgICJjZWxsRGF0ZXMiOiB0cnVlLAogICAgICAgICAgICAgICAgICAgICJjZWxsTkYiOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICAiY2VsbFRleHQiOiBmYWxzZQogICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAidG9Dc3ZPcHRpb25zIjogewogICAgICAgICAgICAgICAgICAgICJkYXRlTkYiOiAiZGQvbW0veXl5eSIsCiAgICAgICAgICAgICAgICAgICAgIkZTIjogIiwiLAogICAgICAgICAgICAgICAgICAgICJSUyI6ICJcbiIKICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgInNoZWV0U2VsZWN0aW9uIjogewogICAgICAgICAgICAgICAgICAgICJ0eXBlIjogewogICAgICAgICAgICAgICAgICAgICAgImF1dG8iOiB0cnVlLAogICAgICAgICAgICAgICAgICAgICAgImluZGV4IjogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6IGZhbHNlCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAiaW5kZXgiOiAwLAogICAgICAgICAgICAgICAgICAgICJuYW1lIjogIiIKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgXQogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgewogICAgICAgICJzdHlsZSI6ICIiLAogICAgICAgICJjZWxscyI6IFsKICAgICAgICAgIHsKICAgICAgICAgICAgInR5cGUiOiAidGFibGUiLAogICAgICAgICAgICAicXVlcnkiOiAiU0VMRUNUICogRlJPTSBzb3VyY2UxIExJTUlUIDEwMCIsCiAgICAgICAgICAgICJtYXhSb3dzIjogMTAwMAogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgewogICAgICAgICJzdHlsZSI6ICIiLAogICAgICAgICJjZWxscyI6IFsKICAgICAgICAgIHsKICAgICAgICAgICAgInR5cGUiOiAic3FsRXhwb3J0IiwKICAgICAgICAgICAgInF1ZXJ5IjogIkNPUFkgKFNFTEVDVCAqIGZyb20gc291cmNlMSkgVE8gJ3tmaWxlTmFtZX0nIChGT1JNQVQgQ1NWLCBIRUFERVIsIERFTElNSVRFUiAnOycpIiwKICAgICAgICAgICAgImZpbGVOYW1lUXVlcnkiOiAiU0VMRUNUICdleHBvcnRfJyB8fCBjdXJyZW50X3RpbWVzdGFtcDo6dGV4dCB8fCAnLmNzdicgYXMgZmlsZV9uYW1lIiwKICAgICAgICAgICAgIm1pbWVUeXBlIjogIiIKICAgICAgICAgIH0KICAgICAgICBdCiAgICAgIH0sCiAgICAgIHsKICAgICAgICAic3R5bGUiOiAiIiwKICAgICAgICAiY2VsbHMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJ0eXBlIjogInBsb3QiLAogICAgICAgICAgICAicXVlcnkiOiAiLy8gVmFyaWFibGVzOiBjb250YWluZXIsIFBsb3RseSwgKyBsZXMgdGFibGVzIGNvbmZpZ3Vyw6llc1xuY29uc3QgbGltaXRlZFNvdXJjZSA9IHNvdXJjZTEuc2xpY2UoMCwgMTAwMCk7XG5jb25zdCB4ID0gbGltaXRlZFNvdXJjZS5tYXAociA9PiBPYmplY3QudmFsdWVzKHIpWzBdKTtcbmNvbnN0IHkgPSBsaW1pdGVkU291cmNlLm1hcChyID0+IE9iamVjdC52YWx1ZXMocilbMV0pO1xuXG5QbG90bHkubmV3UGxvdChjb250YWluZXIsIFt7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHR5cGU6IFwiYmFyXCJcbn1dLCB7IHRpdGxlOiBcIkdyYXBoaXF1ZVwiIH0pOyIsCiAgICAgICAgICAgICJ0YWJsZXMiOiAic291cmNlMSIKICAgICAgICAgIH0KICAgICAgICBdCiAgICAgIH0KICAgIF0KICB9LAogICJ1aSI6IHsKICAgICJkZXZNb2RlIjogdHJ1ZQogIH0KfQ==</script>
</head>
<body>
    <div id="app-container"></div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ARCHITECTURE NOTEBOOK - Syst√®me de cellules
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CLASSE 1: ConfigManager
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class ConfigManager {
            static getDefaultConfig() {
                try {
                    const scriptElement = document.getElementById('defaultConfigBase64');
                    const defaultConfigBase64 = scriptElement?.textContent?.trim();
                    
                    if (!defaultConfigBase64) return { job: { cells: [] } };
                    
                    try {
                        const base64Decoded = atob(defaultConfigBase64);
                        const decoded = decodeURIComponent(escape(base64Decoded));
                        return JSON.parse(decoded);
                    } catch {
                        return JSON.parse(atob(defaultConfigBase64));
                    }
                } catch (error) {
                    console.error('Erreur de d√©codage config:', error);
                    return { job: { cells: [] } };
                }
            }

            static encodeUTF8ToBase64(str) {
                return btoa(unescape(encodeURIComponent(str)));
            }

            static deepMerge(target, source) {
                const output = { ...target };
                if (target && typeof target === 'object' && source && typeof source === 'object') {
                    Object.keys(source).forEach(key => {
                        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                            output[key] = ConfigManager.deepMerge(target[key] || {}, source[key]);
                        } else {
                            output[key] = source[key];
                        }
                    });
                }
                return output;
            }

            /**
             * Charge la configuration depuis un Gist GitHub si pr√©sent dans l'URL
             */
            static async loadConfigFromGist() {
                const gistId = (() => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const gistParam = urlParams.get('gist');
                    if (gistParam && /^[a-f0-9]{32}$/i.test(gistParam)) return gistParam;
                    if (gistParam) {
                        const match = gistParam.match(/gist\.github\.com\/[^\/]+\/([a-f0-9]{32})/i);
                        if (match) return match[1];
                    }
                    const configParam = urlParams.get('config');
                    if (configParam) {
                        const match = configParam.match(/gist\.github\.com\/[^\/]+\/([a-f0-9]{32})/i);
                        if (match) return match[1];
                    }
                    const fullUrlMatch = window.location.href.match(/gist\.github\.com\/[^\/]+\/([a-f0-9]{32})/i);
                    if (fullUrlMatch) return fullUrlMatch[1];
                    return null;
                })();

                if (gistId) {
                    try {
                        console.log('üîó D√©tection d\'un Gist dans l\'URL, chargement de la configuration...', gistId);
                        const apiUrl = `https://api.github.com/gists/${gistId}`;
                        const response = await fetch(apiUrl);
                        if (response.ok) {
                            const gistData = await response.json();
                            const files = Object.values(gistData.files || {});
                            const jsonFile = files.find(file => 
                                file.filename.toLowerCase().endsWith('.json') || 
                                file.type === 'application/json'
                            );
                            if (jsonFile) {
                                try {
                                    const config = JSON.parse(jsonFile.content);
                                    console.log('‚úÖ Configuration charg√©e depuis le Gist:', config);
                                    return ConfigManager.deepMerge(ConfigManager.getDefaultConfig(), config);
                                } catch (parseError) {
                                    console.error('‚ùå Erreur de parsing JSON du Gist:', parseError);
                                    throw new Error(`Le fichier JSON du Gist est invalide. Erreur: ${parseError.message}`);
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Aucun fichier JSON trouv√© dans le Gist');
                            }
                        } else {
                            console.error('‚ùå Erreur HTTP lors du chargement du Gist:', response.status, response.statusText);
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors du chargement du Gist:', error);
                    }
                }
                
                return ConfigManager.getDefaultConfig();
            }

            static cleanCell(cell) {
                const cleanCell = { type: cell.type };
                
                switch (cell.type) {
                    case 'markdown':
                        cleanCell.content = cell.content;
                        break;
                    case 'sources':
                        cleanCell.autoRunNextCells = cell.autoRunNextCells;
                        cleanCell.sources = (cell.sources || []).map(s => ({
                            name: s.name,
                            importText: s.importText,
                            query: s.query,
                            xlsx: s.xlsx
                        }));
                        break;
                    case 'sql':
                        cleanCell.query = cell.query;
                        break;
                    case 'sqlExport':
                        cleanCell.query = cell.query;
                        cleanCell.fileNameQuery = cell.fileNameQuery;
                        cleanCell.mimeType = cell.mimeType;
                        break;
                    case 'table':
                        cleanCell.query = cell.query;
                        cleanCell.maxRows = cell.maxRows;
                        break;
                    case 'plot':
                        cleanCell.query = cell.query;
                        cleanCell.tables = cell.tables;
                        break;
                    case 'iframe':
                        cleanCell.query = cell.query;
                        break;
                }
                
                return cleanCell;
            }

            static buildConfigFromState(rows, devMode = true, autoExecuteWithoutSources = false) {
                const cleanRows = rows.map(row => ({
                    style: row.style || '',
                    cells: row.cells.map(cell => ConfigManager.cleanCell(cell))
                }));
                
                return { 
                    job: { 
                        autoExecuteWithoutSources: autoExecuteWithoutSources,
                        rows: cleanRows 
                    },
                    ui: { devMode: devMode }
                };
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CLASSE 2: FileHandler
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class FileHandler {
            static getMimeTypeFromFileName(fileName) {
                const ext = fileName.split('.').pop().toLowerCase();
                const mimeTypes = {
                    'csv': 'text/csv',
                    'parquet': 'application/octet-stream',
                    'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    'xls': 'application/vnd.ms-excel'
                };
                return mimeTypes[ext] || 'application/octet-stream';
            }

            static async compressGzip(arrayBuffer) {
                if (typeof CompressionStream === 'undefined') {
                    throw new Error('CompressionStream non support√©');
                }
                
                const compressionStream = new CompressionStream('gzip');
                const reader = compressionStream.readable.getReader();
                const chunks = [];
                
                const readPromise = (async () => {
                    let done = false;
                    while (!done) {
                        const { value, done: streamDone } = await reader.read();
                        done = streamDone;
                        if (value) chunks.push(value);
                    }
                })();
                
                const writer = compressionStream.writable.getWriter();
                await writer.write(new Uint8Array(arrayBuffer));
                await writer.close();
                await readPromise;
                
                return await new Blob(chunks).arrayBuffer();
            }

            static async decompressGzip(compressedData) {
                if (typeof DecompressionStream === 'undefined') {
                    throw new Error('DecompressionStream non support√©');
                }
                
                const decompressionStream = new DecompressionStream('gzip');
                const reader = decompressionStream.readable.getReader();
                const chunks = [];
                
                const readPromise = (async () => {
                    let done = false;
                    while (!done) {
                        const { value, done: streamDone } = await reader.read();
                        done = streamDone;
                        if (value) chunks.push(value);
                    }
                })();
                
                const writer = decompressionStream.writable.getWriter();
                await writer.write(compressedData);
                await writer.close();
                await readPromise;
                
                return await new Blob(chunks).arrayBuffer();
            }

            static arrayBufferToBase64(arrayBuffer) {
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                for (let i = 0; i < bytes.length; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            static base64ToUint8Array(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            static async processExcelFile(file, xlsxOptions, xlsxToCsvOptions, xlsxSheetSelection) {
                const workbook = XLSX.read(await file.arrayBuffer(), { type: 'array', ...xlsxOptions });
                
                let selectedSheetName = workbook.SheetNames[0];
                const sheetSelection = xlsxSheetSelection || { type: { auto: true } };
                
                if (sheetSelection.type?.name && sheetSelection.name) {
                    if (workbook.SheetNames.includes(sheetSelection.name)) {
                        selectedSheetName = sheetSelection.name;
                    }
                } else if (sheetSelection.type?.index && sheetSelection.index > 0) {
                    if (sheetSelection.index < workbook.SheetNames.length) {
                        selectedSheetName = workbook.SheetNames[sheetSelection.index];
                    }
                }
                
                const selectedSheet = workbook.Sheets[selectedSheetName];
                const csv = XLSX.utils.sheet_to_csv(selectedSheet, xlsxToCsvOptions || {});
                
                return {
                    csv,
                    csvFileName: file.name.replace(/\.(xlsx|xls)$/i, '.csv'),
                    sheetName: selectedSheetName
                };
            }

            static downloadFile(blob, fileName) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CLASSE 3: DuckDBManager
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class DuckDBManager {
            static dbInstance = null;
            static connInstance = null;
            static duckdbModuleRef = null;

            static async initDuckDB(onStatus) {
                if (DuckDBManager.dbInstance && DuckDBManager.connInstance) {
                    return { db: DuckDBManager.dbInstance, conn: DuckDBManager.connInstance };
                }
                
                onStatus?.('Initialisation de DuckDB...', 'loading');
                
                const duckdb = await import(window.duckDbLibraryUrl);
                window.duckdbModule = duckdb;
                DuckDBManager.duckdbModuleRef = duckdb;
                
                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);

                const worker_url = URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
                );
                const worker = new Worker(worker_url);
                const logger = new duckdb.ConsoleLogger(duckdb.LogLevel.INFO);
                
                DuckDBManager.dbInstance = new duckdb.AsyncDuckDB(logger, worker);
                URL.revokeObjectURL(worker_url);

                await DuckDBManager.dbInstance.instantiate(bundle.mainModule, bundle.pthreadWorker);
                DuckDBManager.connInstance = await DuckDBManager.dbInstance.connect();
                
                onStatus?.('DuckDB pr√™t', 'success');
                
                return { db: DuckDBManager.dbInstance, conn: DuckDBManager.connInstance };
            }

            static async executeQuery(query) {
                if (!DuckDBManager.connInstance) {
                    throw new Error('DuckDB non initialis√©');
                }
                const result = await DuckDBManager.connInstance.query(query);
                return result.toArray().map(row => Object.fromEntries(row));
            }

            static async registerFile(fileName, file) {
                if (!DuckDBManager.dbInstance || !DuckDBManager.duckdbModuleRef) {
                    throw new Error('DuckDB non initialis√©');
                }
                await DuckDBManager.dbInstance.registerFileHandle(
                    fileName, 
                    file, 
                    DuckDBManager.duckdbModuleRef.DuckDBDataProtocol.BROWSER_FILEREADER, 
                    true
                );
            }

            static async copyFileToBuffer(fileName) {
                return await DuckDBManager.dbInstance.copyFileToBuffer(fileName);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CLASSE 4: PlotlyManager
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class PlotlyManager {
            static cleanData(data) {
                if (!data || data.length === 0) return [];
                
                return data.map(row => {
                    const cleanRow = {};
                    for (const [key, value] of Object.entries(row)) {
                        if (typeof value === 'bigint') {
                            cleanRow[key] = Number(value);
                        } else if (typeof value === 'string' && value.trim() !== '' && !isNaN(value)) {
                            cleanRow[key] = parseFloat(value);
                        } else {
                            cleanRow[key] = value;
                        }
                    }
                    return cleanRow;
                });
            }

            static async createPlot(code, tablesData, container) {
                // Nettoyer toutes les tables
                const cleanTables = {};
                for (const [tableName, tableData] of Object.entries(tablesData)) {
                    cleanTables[tableName] = PlotlyManager.cleanData(tableData);
                }
                
                container.innerHTML = '';

                try {
                    // Cr√©er les variables pour chaque table
                    const tableVars = Object.entries(cleanTables)
                        .map(([name, arr]) => `const ${name} = ${JSON.stringify(arr)};`)
                        .join('\n');
                    
                    const executeCode = async (container, Plotly) => {
                        return eval(`(async () => { 
                            ${tableVars}
                            ${code} 
                        })()`);
                    };
                    
                    await executeCode(container, Plotly);
                } catch (error) {
                    console.error('Erreur Plotly:', error);
                    container.innerHTML = `<p style="color: red; text-align: center;">Erreur: ${error.message}</p>`;
                    throw error;
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TEMPLATE HTML
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function generateAppHTML() {
            return `
    <div x-data="notebookApp()" x-init="init()">
        <!-- Header fixe -->
        <div id="fixedButtonsContainer">
            <div class="header-left">
                <span class="header-title">ü¶Ü sqlJob Notebook</span>
            </div>
            <div class="header-right">
                <button class="btn-header" @click="runAllRows()" :disabled="isLoading">
                    ‚ñ∂Ô∏è Tout ex√©cuter
                </button>
                <!-- Mode dev : menu export complet -->
                <template x-if="devMode">
                    <div class="dropdown" :class="{ 'open': exportDropdownOpen }" @click.away="exportDropdownOpen = false">
                        <button class="btn-header" @click="exportDropdownOpen = !exportDropdownOpen">
                            üì§ Export ‚ñæ
                        </button>
                        <div class="dropdown-content">
                            <button class="dropdown-item" @click="exportHTML(); exportDropdownOpen = false" :disabled="isLoading">
                                üíæ HTML
                            </button>
                            <button class="dropdown-item" @click="exportConfig(); exportDropdownOpen = false">
                                üì¶ JSON
                            </button>
                            <button class="dropdown-item" @click="exportConfigBase64(); exportDropdownOpen = false">
                                üîê Base64
                            </button>
                            <button class="dropdown-item" @click="exportPDF(); exportDropdownOpen = false">
                                üìÑ PDF
                            </button>
                        </div>
                    </div>
                </template>
                <!-- Mode non-dev : seulement PDF -->
                <template x-if="!devMode">
                    <button class="btn-header" @click="exportPDF()">
                        üìÑ PDF
                    </button>
                </template>
                <!-- Import JSON : seulement en mode dev -->
                <label x-show="devMode" class="btn-header" style="cursor: pointer;">
                    üìÇ Import JSON
                    <input type="file" accept=".json" @change="loadConfig($event)" style="display: none;">
                </label>
            </div>
        </div>
        
        <div class="app-container">
            <div class="rows-container">
                <template x-for="(row, rowIndex) in rows" :key="row._id">
                    <div class="row-wrapper">
                        <!-- S√©parateur avant la ligne (sauf pour la premi√®re) -->
                        <div class="row-separator" x-show="devMode && rowIndex > 0" @click="openInsertRowModal(rowIndex)">
                            <button class="separator-btn" title="Ins√©rer une ligne ici">+</button>
                        </div>
                        
                        <!-- Row header en mode dev -->
                        <div class="row-header" x-show="devMode">
                            <span>üìã Ligne <span x-text="rowIndex + 1"></span></span>
                            <div class="row-header-actions">
                                <button class="btn-row" @click="runRow(rowIndex)" :disabled="isLoading" title="Ex√©cuter la ligne">
                                    ‚ñ∂Ô∏è
                                </button>
                                <button class="btn-row" @click="openRowConfig(rowIndex)" title="Configurer le style">
                                    ‚öôÔ∏è
                                </button>
                                <button class="btn-row" @click="moveRow(rowIndex, -1)" :disabled="rowIndex === 0" title="Monter">
                                    ‚¨ÜÔ∏è
                                </button>
                                <button class="btn-row" @click="moveRow(rowIndex, 1)" :disabled="rowIndex === rows.length - 1" title="Descendre">
                                    ‚¨áÔ∏è
                                </button>
                                <button class="btn-row" @click="deleteRow(rowIndex)" title="Supprimer la ligne" style="color: var(--error);">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                        
                        <!-- Contenu de la ligne -->
                        <div class="row" :style="row.style">
                            <div class="row-cells">
                                <template x-for="(cell, cellIndex) in row.cells" :key="cell._id">
                                    <div class="cell-with-separator" style="display: contents;">
                                        <!-- S√©parateur avant la cellule (sauf pour la premi√®re) -->
                                        <div class="cell-separator" x-show="devMode && cellIndex > 0" @click="openInsertCellModal(rowIndex, cellIndex)">
                                            <button class="separator-btn" title="Ins√©rer une cellule ici">+</button>
                                        </div>
                                        
                                        <!-- Masquer compl√®tement les cellules SQL en mode non-dev -->
                                        <div class="cell" 
                                         x-show="devMode || cell.type !== 'sql'"
                                         :class="{ 'running': cell._status === 'running', 'success': cell._status === 'success', 'error': cell._status === 'error' }">
                                        <!-- Cell header : visible seulement en mode dev -->
                                        <div class="cell-header" x-show="devMode">
                                            <div class="cell-type-badge">
                                                <span class="cell-type-icon" x-text="getCellIcon(cell.type)"></span>
                                                <span x-text="cell.type"></span>
                                                <span x-show="cell._status === 'running'" style="color: var(--warning);">‚è≥</span>
                                            </div>
                                            <div class="cell-actions">
                                                <button class="btn-cell play" @click="runCellAt(rowIndex, cellIndex)" :disabled="isLoading" title="Ex√©cuter">
                                                    ‚ñ∂Ô∏è
                                                </button>
                                                <button class="btn-cell" @click="openCellConfig(rowIndex, cellIndex)" title="Configurer">
                                                    ‚öôÔ∏è
                                                </button>
                                                <button class="btn-cell" @click="moveCellInRow(rowIndex, cellIndex, -1)" :disabled="cellIndex === 0" title="D√©placer √† gauche">
                                                    ‚¨ÖÔ∏è
                                                </button>
                                                <button class="btn-cell" @click="moveCellInRow(rowIndex, cellIndex, 1)" :disabled="cellIndex === row.cells.length - 1" title="D√©placer √† droite">
                                                    ‚û°Ô∏è
                                                </button>
                                                <button class="btn-cell delete" @click="deleteCellAt(rowIndex, cellIndex)" title="Supprimer">
                                                    üóëÔ∏è
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="cell-body">
                                            <!-- MARKDOWN CELL -->
                                            <template x-if="cell.type === 'markdown'">
                                                <div class="markdown-content" x-html="renderMarkdown(cell.content)"></div>
                                            </template>
                                            
                                            <!-- SOURCES CELL -->
                                            <template x-if="cell.type === 'sources'">
                                                <div>
                                                    <div class="sources-grid">
                                                        <template x-for="(source, sIndex) in cell.sources" :key="source.name + '_' + sIndex">
                                                            <div class="source-item">
                                                                <div class="source-header">
                                                                    <span class="source-name" x-text="'üìÇ ' + source.name"></span>
                                                                    <button class="btn-cell" @click="openSourceConfig(rowIndex, cellIndex, sIndex)" title="Configurer">‚öôÔ∏è</button>
                                                                </div>
                                                                <div class="drop-zone" 
                                                                     :class="{ 'drag-over': source._isDragging, 'has-file': source._fileName }"
                                                                     @click="!source._fileName && document.getElementById('fileInput_' + cell._id + '_' + sIndex).click()"
                                                                     @dragover.prevent="source._isDragging = true"
                                                                     @dragleave.prevent="source._isDragging = false"
                                                                     @drop.prevent="handleSourceDrop($event, rowIndex, cellIndex, sIndex)">
                                                                    <template x-if="!source._fileName">
                                                                        <div>
                                                                            <div>üìÅ</div>
                                                                            <p x-text="source.importText || 'Glissez-d√©posez ici'"></p>
                                                                        </div>
                                                                    </template>
                                                                    <template x-if="source._fileName">
                                                                        <div class="file-info">
                                                                            <span class="file-name">
                                                                                ‚úÖ <span x-text="source._fileName"></span>
                                                                            </span>
                                                                            <button class="btn-cell delete" @click.stop="removeSourceFile(rowIndex, cellIndex, sIndex)">‚ùå</button>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                                <input type="file" 
                                                                       class="file-input"
                                                                       :id="'fileInput_' + cell._id + '_' + sIndex"
                                                                       accept=".csv,.parquet,.xlsx,.xls"
                                                                       @change="handleSourceFileSelect($event, rowIndex, cellIndex, sIndex)">
                                                            </div>
                                                        </template>
                                                    </div>
                                                    <button x-show="devMode" class="btn-add-cell" style="margin-top: 1rem; width: auto;" @click="addSourceToCell(rowIndex, cellIndex)">
                                                        ‚ûï Ajouter une source
                                                    </button>
                                                </div>
                                            </template>
                                            
                                            <!-- SQL CELL -->
                                            <template x-if="cell.type === 'sql'">
                                                <div>
                                                    <textarea class="sql-editor" 
                                                              x-model="cell.query"
                                                              placeholder="SELECT * FROM source1 LIMIT 100"></textarea>
                                                    <template x-if="cell._resultInfo">
                                                        <div class="cell-result-info" x-text="cell._resultInfo"></div>
                                                    </template>
                                                </div>
                                            </template>
                                            
                                            <!-- SQL EXPORT CELL -->
                                            <template x-if="cell.type === 'sqlExport'">
                                                <div>
                                                    <textarea x-show="devMode" class="sql-editor" 
                                                              x-model="cell.query"
                                                              placeholder="COPY (SELECT * from source1) TO &#39;{fileName}&#39; (FORMAT CSV, HEADER)"></textarea>
                                                    <template x-if="cell._resultInfo">
                                                        <div class="cell-result-info" x-text="cell._resultInfo"></div>
                                                    </template>
                                                </div>
                                            </template>
                                            
                                            <!-- TABLE CELL -->
                                            <template x-if="cell.type === 'table'">
                                                <div>
                                                    <textarea x-show="devMode" class="sql-editor" 
                                                              x-model="cell.query"
                                                              placeholder="SELECT * FROM source1 LIMIT 100"></textarea>
                                                    <div class="table-container" :id="'table-' + cell._id" x-show="cell._results"></div>
                                                    <template x-if="cell._resultInfo">
                                                        <div class="cell-result-info" x-text="cell._resultInfo"></div>
                                                    </template>
                                                </div>
                                            </template>
                                            
                                            <!-- PLOT CELL -->
                                            <template x-if="cell.type === 'plot'">
                                                <div>
                                                    <div class="plot-container" :id="'plot-' + cell._id">
                                                        <p x-show="devMode" style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                                                            üìà Cliquez sur ‚öôÔ∏è pour configurer le graphique
                                                        </p>
                                                    </div>
                                                </div>
                                            </template>
                                            
                                            <!-- IFRAME CELL -->
                                            <template x-if="cell.type === 'iframe'">
                                                <div>
                                                    <textarea x-show="devMode" class="sql-editor" 
                                                              x-model="cell.query"
                                                              placeholder="SELECT &#39;&lt;!DOCTYPE html&gt;...&#39; as html"></textarea>
                                                    <div class="iframe-container">
                                                        <iframe :id="'iframe-' + cell._id"></iframe>
                                                    </div>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                    </div>
                                </template>
                            </div>
                            
                            <!-- Bouton ajouter cellule √† droite -->
                            <div class="row-actions" x-show="devMode">
                                <button class="btn-row-add" @click="openAddCellToRowModal(rowIndex)" title="Ajouter une cellule √† droite">
                                    ‚ûï
                                </button>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
            
            <div x-show="devMode" class="add-row-container">
                <button class="btn-add-row" @click="openAddRowModal()">
                    ‚ûï Ajouter une ligne
                </button>
            </div>
        </div>
        
        <!-- Modal ajout ligne -->
        <template x-if="showAddRowModal">
            <div class="modal-overlay" @click.self="showAddRowModal = false">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚ûï Ajouter une ligne</span>
                        <button class="modal-close" @click="showAddRowModal = false">√ó</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem; color: var(--text-secondary);">Choisissez le type de cellule pour la nouvelle ligne :</p>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                            <template x-for="cellType in cellTypes" :key="cellType.type">
                                <button class="btn-header" style="justify-content: flex-start; padding: 1rem;" @click="addRow(cellType.type)">
                                    <span x-text="cellType.icon"></span>
                                    <span x-text="cellType.label"></span>
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal ajout cellule √† une ligne -->
        <template x-if="addCellToRowModal.open">
            <div class="modal-overlay" @click.self="addCellToRowModal.open = false">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚ûï Ajouter une cellule √† la ligne <span x-text="addCellToRowModal.rowIndex + 1"></span></span>
                        <button class="modal-close" @click="addCellToRowModal.open = false">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                            <template x-for="cellType in cellTypes" :key="cellType.type">
                                <button class="btn-header" style="justify-content: flex-start; padding: 1rem;" @click="addCellToRow(addCellToRowModal.rowIndex, cellType.type)">
                                    <span x-text="cellType.icon"></span>
                                    <span x-text="cellType.label"></span>
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal insertion ligne entre deux lignes -->
        <template x-if="insertRowModal.open">
            <div class="modal-overlay" @click.self="insertRowModal.open = false">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚ûï Ins√©rer une ligne √† la position <span x-text="insertRowModal.atIndex + 1"></span></span>
                        <button class="modal-close" @click="insertRowModal.open = false">√ó</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem; color: var(--text-secondary);">Choisissez le type de cellule pour la nouvelle ligne :</p>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                            <template x-for="cellType in cellTypes" :key="cellType.type">
                                <button class="btn-header" style="justify-content: flex-start; padding: 1rem;" @click="insertRowAt(insertRowModal.atIndex, cellType.type)">
                                    <span x-text="cellType.icon"></span>
                                    <span x-text="cellType.label"></span>
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal insertion cellule entre deux cellules -->
        <template x-if="insertCellModal.open">
            <div class="modal-overlay" @click.self="insertCellModal.open = false">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚ûï Ins√©rer une cellule √† la position <span x-text="insertCellModal.atCellIndex + 1"></span></span>
                        <button class="modal-close" @click="insertCellModal.open = false">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                            <template x-for="cellType in cellTypes" :key="cellType.type">
                                <button class="btn-header" style="justify-content: flex-start; padding: 1rem;" @click="insertCellAt(insertCellModal.rowIndex, insertCellModal.atCellIndex, cellType.type)">
                                    <span x-text="cellType.icon"></span>
                                    <span x-text="cellType.label"></span>
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal configuration cellule -->
        <template x-if="cellConfigModal.open">
            <div class="modal-overlay" @click.self="closeCellConfig()">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚öôÔ∏è Configuration de la cellule</span>
                        <button class="modal-close" @click="closeCellConfig()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-field">
                            <label>Type de cellule</label>
                            <select x-ref="typeSelect"
                                    x-effect="if (cellConfigModal.open && cellConfigModal.rowIndex !== null) $refs.typeSelect.value = getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type"
                                    @change="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).type = $event.target.value; onCellTypeChange(cellConfigModal.rowIndex, cellConfigModal.cellIndex)">
                                <option value="markdown">üìù Markdown</option>
                                <option value="sources">üìÇ Sources</option>
                                <option value="sql">üóÑÔ∏è SQL</option>
                                <option value="sqlExport">üì§ SQL Export</option>
                                <option value="table">üìä Tableau</option>
                                <option value="plot">üìà Graphique</option>
                                <option value="iframe">üñºÔ∏è HTML/Iframe</option>
                            </select>
                        </div>
                        
                        <!-- Config sp√©cifique markdown -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'markdown'">
                            <div class="form-field">
                                <label>Contenu Markdown</label>
                                <textarea x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).content" rows="5"></textarea>
                            </div>
                        </template>
                        
                        <!-- Config sp√©cifique sources -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'sources'">
                            <div class="form-field checkbox-field">
                                <input type="checkbox" x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).autoRunNextCells">
                                <label>Ex√©cuter automatiquement les lignes suivantes</label>
                            </div>
                        </template>
                        
                        <!-- Config sp√©cifique sqlExport -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'sqlExport'">
                            <div>
                                <div class="form-field">
                                    <label>Requ√™te nom de fichier</label>
                                    <textarea x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).fileNameQuery" rows="2"
                                              placeholder="SELECT &#39;export.csv&#39; as file_name"></textarea>
                                </div>
                                <div class="form-field">
                                    <label>Type MIME (optionnel)</label>
                                    <input type="text" x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).mimeType" placeholder="text/csv">
                                </div>
                            </div>
                        </template>
                        
                        <!-- Config sp√©cifique table -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'table'">
                            <div class="form-field">
                                <label>Nombre max de lignes</label>
                                <input type="number" x-model.number="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).maxRows" placeholder="1000">
                            </div>
                        </template>
                        
                        <!-- Config sp√©cifique plot -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'plot'">
                            <div>
                                <div class="form-field">
                                    <label>Tables √† charger</label>
                                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin: 0 0 0.5rem;">
                                        Noms des tables DuckDB √† utiliser, s√©par√©s par des virgules (ex: <code>source1, clients, ventes</code>)
                                    </p>
                                    <input type="text" x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).tables" 
                                           placeholder="data, clients, ventes">
                                </div>
                                <div class="form-field">
                                    <label>Code Plotly.js</label>
                                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin: 0 0 0.5rem;">
                                        Variables disponibles : <code>container</code> (√©l√©ment DOM), <code>Plotly</code>, et les tables configur√©es ci-dessus
                                    </p>
                                    <textarea x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).query" rows="10"
                                              style="min-height: 200px;"
                                              placeholder="// Exemple de graphique (utilise la table 'source1')
const limitedSource = source1.slice(0, 1000);
const x = limitedSource.map(r => Object.values(r)[0]);
const y = limitedSource.map(r => Object.values(r)[1]);

Plotly.newPlot(container, [{
    x: x,
    y: y,
    type: 'bar'
}], {
    title: 'Mon graphique'
});"></textarea>
                                </div>
                            </div>
                        </template>
                        
                        <!-- Config sp√©cifique iframe -->
                        <template x-if="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex)?.type === 'iframe'">
                            <div class="form-field">
                                <label>Requ√™te SQL (doit retourner du HTML)</label>
                                <textarea x-model="getCell(cellConfigModal.rowIndex, cellConfigModal.cellIndex).query" rows="3"
                                          placeholder="SELECT '&lt;html&gt;...&lt;/html&gt;' as html"></textarea>
                            </div>
                        </template>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-modal secondary" @click="closeCellConfig()">Fermer</button>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal configuration ligne -->
        <template x-if="rowConfigModal.open">
            <div class="modal-overlay" @click.self="rowConfigModal.open = false">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚öôÔ∏è Configuration de la ligne <span x-text="rowConfigModal.rowIndex + 1"></span></span>
                        <button class="modal-close" @click="rowConfigModal.open = false">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-field">
                            <label>Style CSS de la ligne</label>
                            <p style="font-size: 0.8rem; color: var(--text-secondary); margin: 0 0 0.5rem;">
                                Ex: <code>flex-direction: column;</code> pour empiler les cellules verticalement
                            </p>
                            <textarea x-model="rows[rowConfigModal.rowIndex].style" rows="3"
                                      placeholder="flex-direction: row;"></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-modal secondary" @click="rowConfigModal.open = false">Fermer</button>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- Modal configuration source -->
        <template x-if="sourceConfigModal.open">
            <div class="modal-overlay" @click.self="closeSourceConfig()">
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="modal-title">‚öôÔ∏è Configuration de la source</span>
                        <button class="modal-close" @click="closeSourceConfig()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-field">
                            <label>Nom de la source (nom de table)</label>
                            <input type="text" x-model="getCell(sourceConfigModal.rowIndex, sourceConfigModal.cellIndex).sources[sourceConfigModal.sourceIndex].name">
                        </div>
                        <div class="form-field">
                            <label>Texte de la zone d'import</label>
                            <input type="text" x-model="getCell(sourceConfigModal.rowIndex, sourceConfigModal.cellIndex).sources[sourceConfigModal.sourceIndex].importText">
                        </div>
                        <div class="form-field">
                            <label>Requ√™te d'import (utilise {fileNameUpload})</label>
                            <textarea x-model="getCell(sourceConfigModal.rowIndex, sourceConfigModal.cellIndex).sources[sourceConfigModal.sourceIndex].query" rows="3"></textarea>
                        </div>
                        <div class="form-field">
                            <label>Configuration Excel (JSON)</label>
                            <textarea :value="JSON.stringify(getCell(sourceConfigModal.rowIndex, sourceConfigModal.cellIndex).sources[sourceConfigModal.sourceIndex].xlsx || {}, null, 2)"
                                      @input="updateSourceXlsx($event.target.value)" rows="5"></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-modal secondary" style="color: var(--error);" @click="removeSourceFromCell()">üóëÔ∏è Supprimer</button>
                        <button class="btn-modal secondary" @click="closeSourceConfig()">Fermer</button>
                    </div>
                </div>
            </div>
        </template>
        
        <!-- DevMode Toggle -->
        <div class="bottom-controls">
            <!-- Bouton switch Light/Dark -->
            <button class="control-btn theme-btn" @click="toggleTheme()" :title="isDarkMode ? 'Passer en mode clair' : 'Passer en mode sombre'">
                <span x-text="isDarkMode ? '‚òÄÔ∏è' : 'üåô'"></span>
            </button>
            <!-- Bouton Dev/View -->
            <button class="control-btn" :class="{ 'active': devMode }" @click="devMode = !devMode">
                <span x-text="devMode ? 'üëÅÔ∏è' : 'üîß'"></span>
            </button>
        </div>
        
        <!-- Status bar -->
        <template x-if="status">
            <div class="status-bar" :class="statusType" x-text="status"></div>
        </template>
        
        <footer>
            iHateXcel - sqlJob - Made with ‚ù§Ô∏è by Th√©o Nobella-Pichonnier
        </footer>
    </div>`;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // APPLICATION ALPINE.JS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function notebookApp() {
            // Utiliser la config charg√©e depuis le Gist si disponible, sinon la config par d√©faut
            const config = window._loadedConfig || ConfigManager.getDefaultConfig();
            
            // Helper pour initialiser une cellule avec ses propri√©t√©s runtime
            const initCell = (cell, cellIndex) => ({
                ...cell,
                _id: 'cell_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                _status: null,
                _results: null,
                _resultInfo: null,
                sources: cell.type === 'sources' ? (cell.sources || []).map(s => ({
                    ...s,
                    _fileName: '',
                    _currentFile: null,
                    _isDragging: false,
                    _loaded: false
                })) : undefined
            });
            
            // Initialiser les lignes depuis la config
            const initRows = (config.job?.rows || []).map((row, rowIndex) => ({
                _id: 'row_' + Date.now() + '_' + rowIndex,
                style: row.style || '',
                cells: (row.cells || []).map((cell, cellIndex) => initCell(cell, cellIndex))
            }));
            
            // Mode d√©veloppeur (true = affichage complet, false = mode utilisateur simplifi√©)
            const devMode = config.ui?.devMode !== false;
            
            // Auto-ex√©cution si pas de sources
            const autoExecuteWithoutSources = config.job?.autoExecuteWithoutSources === true;
            
            // Gestion du th√®me (light par d√©faut)
            const savedTheme = localStorage.getItem('sqljob-theme');
            const isDarkMode = savedTheme === 'dark';
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
            
            return {
                rows: initRows,
                isLoading: false,
                status: '',
                statusType: '',
                devMode: devMode,
                autoExecuteWithoutSources: autoExecuteWithoutSources,
                isDarkMode: isDarkMode,
                
                // Modals & Dropdowns
                showAddRowModal: false,
                addCellToRowModal: { open: false, rowIndex: null },
                insertRowModal: { open: false, atIndex: null },
                insertCellModal: { open: false, rowIndex: null, atCellIndex: null },
                cellConfigModal: { open: false, rowIndex: null, cellIndex: null },
                sourceConfigModal: { open: false, rowIndex: null, cellIndex: null, sourceIndex: null },
                rowConfigModal: { open: false, rowIndex: null },
                exportDropdownOpen: false,
                
                // Types de cellules disponibles
                cellTypes: [
                    { type: 'markdown', label: 'Markdown', icon: 'üìù' },
                    { type: 'sources', label: 'Sources', icon: 'üìÇ' },
                    { type: 'sql', label: 'SQL', icon: 'üóÑÔ∏è' },
                    { type: 'sqlExport', label: 'SQL Export', icon: 'üì§' },
                    { type: 'table', label: 'Tableau', icon: 'üìä' },
                    { type: 'plot', label: 'Graphique', icon: 'üìà' },
                    { type: 'iframe', label: 'HTML/Iframe', icon: 'üñºÔ∏è' }
                ],
                
                // Tables Tabulator par cellule
                _tables: {},
                
                // Cache des donn√©es des tables DuckDB pour les plots
                _tablesDataCache: {},
                _tablesDataCacheValid: false,
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // INITIALISATION
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                async init() {
                    try {
                        await DuckDBManager.initDuckDB((msg, type) => this.setStatus(msg, type));
                        // Charger les fichiers embarqu√©s dans le HTML
                        await this.loadEmbeddedFiles();
                        
                        // Auto-ex√©cution si pas de cellule sources et option activ√©e
                        if (this.autoExecuteWithoutSources) {
                            const hasSourcesCell = this.rows.some(row => row.cells.some(cell => cell.type === 'sources'));
                            if (!hasSourcesCell) {
                                console.log('‚ö° Auto-ex√©cution : aucune cellule sources d√©tect√©e');
                                await this.runAllRows();
                            }
                        }
                    } catch (error) {
                        this.setStatus('Erreur d\'initialisation: ' + error.message, 'error');
                    }
                },
                
                async loadEmbeddedFiles() {
                    // Chercher toutes les balises script avec les fichiers embarqu√©s
                    const sourceFileScripts = document.querySelectorAll('script[id^="sourceFile_"]');
                    
                    if (sourceFileScripts.length === 0) {
                        return; // Pas de fichiers embarqu√©s, c'est normal
                    }
                    
                    console.info('üìÇ ' + sourceFileScripts.length + ' fichier(s) embarqu√©(s) trouv√©(s)');
                    
                    for (const script of sourceFileScripts) {
                        const sourceName = script.dataset.sourceName;
                        const fileName = script.dataset.fileName;
                        const base64Data = script.textContent.trim();
                        
                        if (!sourceName || !fileName || !base64Data) {
                            console.warn('Script source incomplet:', script.id);
                            continue;
                        }
                        
                        // Trouver la cellule sources et la source correspondante dans les rows
                        let targetRowIndex = -1;
                        let targetCellIndex = -1;
                        let targetSource = null;
                        let targetSourceIndex = -1;
                        
                        for (let ri = 0; ri < this.rows.length; ri++) {
                            const row = this.rows[ri];
                            for (let ci = 0; ci < row.cells.length; ci++) {
                                const cell = row.cells[ci];
                                if (cell.type === 'sources' && cell.sources) {
                                    for (let si = 0; si < cell.sources.length; si++) {
                                        if (cell.sources[si].name === sourceName) {
                                            targetRowIndex = ri;
                                            targetCellIndex = ci;
                                            targetSource = cell.sources[si];
                                            targetSourceIndex = si;
                                            break;
                                        }
                                    }
                                }
                                if (targetSource) break;
                            }
                            if (targetSource) break;
                        }
                        
                        if (!targetSource) {
                            console.warn(`Source "${sourceName}" non trouv√©e dans les cellules`);
                            continue;
                        }
                        
                        try {
                            this.setStatus(`Chargement de ${sourceName}...`, 'loading');
                            
                            // D√©coder et d√©compresser
                            const bytes = FileHandler.base64ToUint8Array(base64Data);
                            const decompressedBuffer = await FileHandler.decompressGzip(bytes);
                            
                            // Cr√©er un File object
                            const blob = new Blob([decompressedBuffer]);
                            const file = new File([blob], fileName, {
                                type: FileHandler.getMimeTypeFromFileName(fileName)
                            });
                            
                            // Charger le fichier dans la source
                            await this.loadSourceFile(file, targetRowIndex, targetCellIndex, targetSourceIndex);
                            
                            console.log(`‚úÖ Fichier "${fileName}" charg√© pour la source "${sourceName}"`);
                        } catch (error) {
                            console.error(`Erreur chargement fichier embarqu√© ${sourceName}:`, error);
                            this.setStatus(`Erreur: ${error.message}`, 'error');
                        }
                    }
                    
                    this.setStatus('Fichiers embarqu√©s charg√©s', 'success');
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // HELPERS
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                setStatus(message, type) {
                    this.status = message;
                    this.statusType = type;
                    if (type !== 'loading') {
                        setTimeout(() => { this.status = ''; this.statusType = ''; }, 4000);
                    }
                },
                
                renderMarkdown(content) {
                    if (!content) return '';
                    return typeof marked !== 'undefined' ? marked.parse(content, { breaks: true, gfm: true }) : content;
                },
                
                getCellIcon(type) {
                    const found = this.cellTypes.find(ct => ct.type === type);
                    return found ? found.icon : 'üìÑ';
                },
                
                generateCellId() {
                    return 'cell_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                },
                
                generateRowId() {
                    return 'row_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                },
                
                // Helper pour acc√©der √† une cellule par ses indices
                getCell(rowIndex, cellIndex) {
                    return this.rows[rowIndex]?.cells[cellIndex];
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // GESTION DES LIGNES (ROWS)
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                openAddRowModal() {
                    this.showAddRowModal = true;
                },
                
                openAddCellToRowModal(rowIndex) {
                    this.addCellToRowModal = { open: true, rowIndex };
                },
                
                openRowConfig(rowIndex) {
                    this.rowConfigModal = { open: true, rowIndex };
                },
                
                createNewCell(type) {
                    const newCell = {
                        _id: this.generateCellId(),
                        _status: null,
                        _results: null,
                        _resultInfo: null,
                        type
                    };
                    
                    switch (type) {
                        case 'markdown':
                            newCell.content = '# Nouvelle section';
                            break;
                        case 'sources':
                            newCell.autoRunNextCells = false;
                            newCell.sources = [{
                                name: 'source1',
                                importText: 'Glissez-d√©posez votre fichier ici',
                                query: "CREATE OR REPLACE TABLE source1 AS SELECT * FROM read_csv_auto('{fileNameUpload}', ALL_VARCHAR=true, HEADER=true)",
                                xlsx: {
                                    options: { type: 'array', raw: false, dateNF: 'dd/mm/yyyy', cellDates: true },
                                    toCsvOptions: { dateNF: 'dd/mm/yyyy', FS: ',', RS: '\n' },
                                    sheetSelection: { type: { auto: true }, index: 0, name: '' }
                                },
                                _fileName: '',
                                _currentFile: null,
                                _isDragging: false,
                                _loaded: false
                            }];
                            break;
                        case 'sql':
                            newCell.query = 'SELECT * FROM source1 LIMIT 100';
                            break;
                        case 'sqlExport':
                            newCell.query = "COPY (SELECT * from source1) TO '{fileName}' (FORMAT CSV, HEADER, DELIMITER ';')";
                            newCell.fileNameQuery = "SELECT 'export_' || current_timestamp::text || '.csv' as file_name";
                            newCell.mimeType = '';
                            break;
                        case 'table':
                            newCell.query = 'SELECT * FROM source1 LIMIT 100';
                            newCell.maxRows = 1000;
                            break;
                        case 'plot':
                            newCell.query = '// Variables: container, Plotly, + les tables configur√©es\nconst limitedSource = source1.slice(0, 1000);\nconst x = limitedSource.map(r => Object.values(r)[0]);\nconst y = limitedSource.map(r => Object.values(r)[1]);\n\nPlotly.newPlot(container, [{\n    x: x,\n    y: y,\n    type: "bar"\n}], { title: "Graphique" });';
                            newCell.tables = 'source1';
                            break;
                        case 'iframe':
                            newCell.query = 'SELECT \'<html><body><h1>Hello</h1></body></html>\' as html';
                            break;
                    }
                    
                    return newCell;
                },
                
                addRow(cellType) {
                    const newRow = {
                        _id: this.generateRowId(),
                        style: '',
                        cells: [this.createNewCell(cellType)]
                    };
                    
                    this.rows.push(newRow);
                    this.showAddRowModal = false;
                },
                
                addCellToRow(rowIndex, cellType) {
                    const row = this.rows[rowIndex];
                    if (row) {
                        row.cells.push(this.createNewCell(cellType));
                    }
                    this.addCellToRowModal = { open: false, rowIndex: null };
                },
                
                // Ouvrir le modal pour ins√©rer une ligne √† une position
                openInsertRowModal(atIndex) {
                    this.insertRowModal = { open: true, atIndex: atIndex };
                },
                
                // Ins√©rer une ligne √† une position sp√©cifique
                insertRowAt(atIndex, cellType) {
                    const newRow = {
                        _id: this.generateRowId(),
                        style: '',
                        cells: [this.createNewCell(cellType)]
                    };
                    this.rows.splice(atIndex, 0, newRow);
                    this.insertRowModal = { open: false, atIndex: null };
                },
                
                // Ouvrir le modal pour ins√©rer une cellule √† une position
                openInsertCellModal(rowIndex, atCellIndex) {
                    this.insertCellModal = { open: true, rowIndex: rowIndex, atCellIndex: atCellIndex };
                },
                
                // Ins√©rer une cellule √† une position sp√©cifique
                insertCellAt(rowIndex, atCellIndex, cellType) {
                    const row = this.rows[rowIndex];
                    if (row) {
                        row.cells.splice(atCellIndex, 0, this.createNewCell(cellType));
                    }
                    this.insertCellModal = { open: false, rowIndex: null, atCellIndex: null };
                },
                
                deleteRow(rowIndex) {
                    if (confirm('Supprimer cette ligne et toutes ses cellules ?')) {
                        const row = this.rows[rowIndex];
                        // Nettoyer les tables Tabulator
                        for (const cell of row.cells) {
                            if (this._tables[cell._id]) {
                                this._tables[cell._id].destroy();
                                delete this._tables[cell._id];
                            }
                        }
                        this.rows.splice(rowIndex, 1);
                    }
                },
                
                moveRow(rowIndex, direction) {
                    const newIndex = rowIndex + direction;
                    if (newIndex >= 0 && newIndex < this.rows.length) {
                        const temp = this.rows[rowIndex];
                        this.rows[rowIndex] = this.rows[newIndex];
                        this.rows[newIndex] = temp;
                    }
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // GESTION DES CELLULES
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                deleteCellAt(rowIndex, cellIndex) {
                    const row = this.rows[rowIndex];
                    if (!row) return;
                    
                    if (row.cells.length === 1) {
                        // Si c'est la derni√®re cellule de la ligne, supprimer la ligne
                        this.deleteRow(rowIndex);
                    } else {
                        if (confirm('Supprimer cette cellule ?')) {
                            const cell = row.cells[cellIndex];
                            if (this._tables[cell._id]) {
                                this._tables[cell._id].destroy();
                                delete this._tables[cell._id];
                            }
                            row.cells.splice(cellIndex, 1);
                        }
                    }
                },
                
                moveCellInRow(rowIndex, cellIndex, direction) {
                    const row = this.rows[rowIndex];
                    if (!row) return;
                    
                    const newIndex = cellIndex + direction;
                    if (newIndex >= 0 && newIndex < row.cells.length) {
                        const temp = row.cells[cellIndex];
                        row.cells[cellIndex] = row.cells[newIndex];
                        row.cells[newIndex] = temp;
                    }
                },
                
                openCellConfig(rowIndex, cellIndex) {
                    this.cellConfigModal = { open: true, rowIndex, cellIndex };
                    // Forcer la mise √† jour du select apr√®s le rendu
                    setTimeout(() => {
                        const select = document.querySelector('.modal-body select');
                        const cell = this.getCell(rowIndex, cellIndex);
                        if (select && cell) {
                            select.value = cell.type;
                        }
                    }, 50);
                },
                
                closeCellConfig() {
                    this.cellConfigModal = { open: false, rowIndex: null, cellIndex: null };
                },
                
                onCellTypeChange(rowIndex, cellIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell) return;
                    
                    // R√©initialiser les propri√©t√©s sp√©cifiques au type
                    cell._results = null;
                    cell._resultInfo = null;
                    
                    // Ajouter les propri√©t√©s manquantes selon le type
                    if (cell.type === 'sources' && !cell.sources) {
                        cell.sources = [];
                        cell.autoRunNextCells = false;
                    }
                    if (cell.type === 'table' && !cell.maxRows) {
                        cell.maxRows = 1000;
                    }
                    if (cell.type === 'plot' && !cell.tables) {
                        cell.tables = 'source1';
                    }
                    if (cell.type === 'sqlExport') {
                        if (!cell.fileNameQuery) cell.fileNameQuery = "SELECT 'export.csv' as file_name";
                        if (!cell.mimeType) cell.mimeType = '';
                    }
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // GESTION DES SOURCES
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                addSourceToCell(rowIndex, cellIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell || cell.type !== 'sources') return;
                    
                    const newName = 'source' + (cell.sources.length + 1);
                    cell.sources.push({
                        name: newName,
                        importText: `Glissez-d√©posez ici (${newName})`,
                        query: `CREATE OR REPLACE TABLE ${newName} AS SELECT * FROM read_csv_auto('{fileNameUpload}', ALL_VARCHAR=true, HEADER=true)`,
                        xlsx: {
                            options: { type: 'array', raw: false, dateNF: 'dd/mm/yyyy', cellDates: true },
                            toCsvOptions: { dateNF: 'dd/mm/yyyy', FS: ',', RS: '\n' },
                            sheetSelection: { type: { auto: true }, index: 0, name: '' }
                        },
                        _fileName: '',
                        _currentFile: null,
                        _isDragging: false,
                        _loaded: false
                    });
                },
                
                openSourceConfig(rowIndex, cellIndex, sourceIndex) {
                    this.sourceConfigModal = { open: true, rowIndex, cellIndex, sourceIndex };
                },
                
                closeSourceConfig() {
                    this.sourceConfigModal = { open: false, rowIndex: null, cellIndex: null, sourceIndex: null };
                },
                
                updateSourceXlsx(jsonString) {
                    try {
                        const xlsx = JSON.parse(jsonString);
                        const cell = this.getCell(this.sourceConfigModal.rowIndex, this.sourceConfigModal.cellIndex);
                        if (cell && cell.sources) {
                            cell.sources[this.sourceConfigModal.sourceIndex].xlsx = xlsx;
                        }
                    } catch (e) {
                        console.warn('JSON invalide pour xlsx config');
                    }
                },
                
                removeSourceFromCell() {
                    const { rowIndex, cellIndex, sourceIndex } = this.sourceConfigModal;
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (cell && cell.sources) {
                        cell.sources.splice(sourceIndex, 1);
                    }
                    this.closeSourceConfig();
                },
                
                handleSourceDrop(e, rowIndex, cellIndex, sourceIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell || !cell.sources) return;
                    
                    const source = cell.sources[sourceIndex];
                    source._isDragging = false;
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadSourceFile(files[0], rowIndex, cellIndex, sourceIndex);
                    }
                },
                
                handleSourceFileSelect(e, rowIndex, cellIndex, sourceIndex) {
                    const files = e.target.files;
                    if (files.length > 0) {
                        this.loadSourceFile(files[0], rowIndex, cellIndex, sourceIndex);
                    }
                },
                
                async loadSourceFile(file, rowIndex, cellIndex, sourceIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell || !cell.sources) return;
                    
                    const source = cell.sources[sourceIndex];
                    
                    source._fileName = file.name;
                    source._currentFile = file;
                    this.isLoading = true;
                    cell._status = 'running';
                    this.setStatus(`Chargement de ${source.name}...`, 'loading');
                    
                    try {
                        await DuckDBManager.registerFile(file.name, file);
                        
                        let loadQuery = (source.query || '').trim();
                        const ext = file.name.split('.').pop().toLowerCase();
                        const tableName = source.name || 'source1';
                        
                        if (ext === 'xlsx' || ext === 'xls') {
                            this.setStatus('Conversion Excel...', 'loading');
                            const { csv, csvFileName } = await FileHandler.processExcelFile(
                                file, 
                                source.xlsx?.options,
                                source.xlsx?.toCsvOptions,
                                source.xlsx?.sheetSelection
                            );
                            
                            const csvBlob = new Blob([csv], { type: 'text/csv' });
                            await DuckDBManager.registerFile(csvFileName, csvBlob);
                            
                            loadQuery = loadQuery 
                                ? loadQuery.replace(/\{fileNameUpload\}/g, csvFileName)
                                : `CREATE OR REPLACE TABLE ${tableName} AS SELECT * FROM read_csv_auto('${csvFileName}', ALL_VARCHAR=true, HEADER=true)`;
                        } else {
                            loadQuery = loadQuery 
                                ? loadQuery.replace(/\{fileNameUpload\}/g, file.name)
                                : `CREATE OR REPLACE TABLE ${tableName} AS SELECT * FROM read_csv_auto('${file.name}', ALL_VARCHAR=true, HEADER=true)`;
                        }
                        
                        await DuckDBManager.executeQuery(loadQuery);
                        source._loaded = true;
                        cell._status = 'success';
                        this.setStatus(`${source.name} charg√©!`, 'success');
                        
                        // Invalider le cache des tables car les donn√©es ont chang√©
                        this.invalidateTablesCache();
                        
                        // V√©rifier si toutes les sources sont charg√©es et autoRunNextCells
                        if (cell.autoRunNextCells && this.allSourcesLoadedInCell(rowIndex, cellIndex)) {
                            await this.runRowsFromIndex(rowIndex + 1);
                        }
                    } catch (error) {
                        cell._status = 'error';
                        this.setStatus('Erreur: ' + error.message, 'error');
                        source._fileName = '';
                        source._currentFile = null;
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                removeSourceFile(rowIndex, cellIndex, sourceIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell || !cell.sources) return;
                    
                    const source = cell.sources[sourceIndex];
                    source._fileName = '';
                    source._currentFile = null;
                    source._loaded = false;
                },
                
                allSourcesLoadedInCell(rowIndex, cellIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell || cell.type !== 'sources') return true;
                    return cell.sources.every(s => s._loaded);
                },
                
                // Invalider le cache des tables (√† appeler quand les donn√©es changent)
                invalidateTablesCache() {
                    this._tablesDataCacheValid = false;
                    this._tablesDataCache = {};
                },
                
                // Charger des tables sp√©cifiques depuis DuckDB
                async loadSpecificTables(tableNames) {
                    const tablesData = {};
                    
                    for (const tableName of tableNames) {
                        const trimmedName = tableName.trim();
                        if (!trimmedName) continue;
                        
                        // V√©rifier si d√©j√† en cache
                        if (this._tablesDataCache[trimmedName]) {
                            tablesData[trimmedName] = this._tablesDataCache[trimmedName];
                            console.log(`  üì¶ ${trimmedName}: depuis le cache`);
                            continue;
                        }
                        
                        try {
                            const tableData = await DuckDBManager.executeQuery(`SELECT * FROM "${trimmedName}"`);
                            tablesData[trimmedName] = tableData;
                            // Mettre en cache
                            this._tablesDataCache[trimmedName] = tableData;
                            console.log(`  ‚úÖ ${trimmedName}: ${tableData.length} lignes charg√©es`);
                        } catch (error) {
                            console.warn(`  ‚ö†Ô∏è Erreur lecture table ${trimmedName}:`, error.message);
                            tablesData[trimmedName] = [];
                        }
                    }
                    
                    return tablesData;
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // EX√âCUTION DES CELLULES
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                async runCellAt(rowIndex, cellIndex) {
                    const cell = this.getCell(rowIndex, cellIndex);
                    if (!cell) return;
                    
                    cell._status = 'running';
                    this.isLoading = true;
                    
                    try {
                        switch (cell.type) {
                            case 'markdown':
                                // Rien √† ex√©cuter
                                break;
                            case 'sources':
                                // Les sources sont charg√©es via le drop
                                break;
                            case 'sql':
                                await this.executeSqlCell(cell);
                                break;
                            case 'sqlExport':
                                await this.executeSqlExportCell(cell);
                                break;
                            case 'table':
                                await this.executeTableCell(cell);
                                break;
                            case 'plot':
                                await this.executePlotCell(cell);
                                break;
                            case 'iframe':
                                await this.executeIframeCell(cell);
                                break;
                        }
                        
                        cell._status = 'success';
                    } catch (error) {
                        cell._status = 'error';
                        cell._resultInfo = 'Erreur: ' + error.message;
                        this.setStatus('Erreur: ' + error.message, 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                // Ex√©cuter toutes les cellules d'une ligne (de gauche √† droite)
                async runRow(rowIndex) {
                    const row = this.rows[rowIndex];
                    if (!row) return;
                    
                    this.setStatus(`Ex√©cution de la ligne ${rowIndex + 1}...`, 'loading');
                    
                    // Ex√©cuter les cellules de gauche √† droite
                    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
                        const cell = row.cells[cellIndex];
                        // Skip sources car elles d√©pendent des fichiers upload√©s
                        if (cell.type !== 'sources') {
                            await this.runCellAt(rowIndex, cellIndex);
                        }
                    }
                    
                    this.setStatus(`Ligne ${rowIndex + 1} ex√©cut√©e`, 'success');
                },
                
                async executeSqlCell(cell) {
                    if (!cell.query?.trim()) return;
                    
                    this.setStatus('Ex√©cution SQL...', 'loading');
                    const results = await DuckDBManager.executeQuery(cell.query);
                    cell._results = results;
                    cell._resultInfo = `‚úÖ ${results.length} ligne(s) affect√©e(s)`;
                    
                    // Invalider le cache car la requ√™te peut avoir modifi√© des tables
                    this.invalidateTablesCache();
                    
                    this.setStatus('SQL ex√©cut√©', 'success');
                },
                
                async executeSqlExportCell(cell) {
                    if (!cell.query?.trim()) return;
                    
                    this.setStatus('Export en cours...', 'loading');
                    
                    // Obtenir le nom de fichier
                    const fileNameQuery = cell.fileNameQuery || "SELECT 'export.csv' as file_name";
                    const fileNameResult = await DuckDBManager.executeQuery(fileNameQuery);
                    const fileNameRow = fileNameResult[0];
                    const keys = Object.keys(fileNameRow);
                    const fileKey = keys.find(k => k.toLowerCase().includes('file'));
                    let outputFile = fileKey ? fileNameRow[fileKey] : Object.values(fileNameRow)[0];
                    outputFile = String(outputFile).replace(/[^\w.\-\/]/g, '_');
                    
                    // Construire et ex√©cuter la requ√™te COPY
                    let copyQuery = cell.query.replace(/\{fileName\}/g, outputFile);
                    
                    await DuckDBManager.executeQuery(copyQuery);
                    
                    const buffer = await DuckDBManager.copyFileToBuffer(outputFile);
                    
                    let mime = cell.mimeType?.trim() || 'text/csv;charset=utf-8;';
                    const blob = new Blob([buffer], { type: mime });
                    FileHandler.downloadFile(blob, outputFile.split('/').pop());
                    
                    cell._resultInfo = `‚úÖ Fichier export√©: ${outputFile}`;
                    this.setStatus('Export r√©ussi!', 'success');
                },
                
                async executeTableCell(cell) {
                    if (!cell.query?.trim()) return;
                    
                    this.setStatus('Chargement tableau...', 'loading');
                    const results = await DuckDBManager.executeQuery(cell.query);
                    
                    const maxRows = cell.maxRows || 1000;
                    const truncated = results.length > maxRows;
                    cell._results = results.slice(0, maxRows);
                    cell._resultInfo = `${results.length} ligne(s)` + (truncated ? ` (limit√© √† ${maxRows})` : '');
                    
                    await this.$nextTick();
                    
                    const containerId = 'table-' + cell._id;
                    const container = document.getElementById(containerId);
                    
                    if (container && cell._results.length > 0) {
                        if (this._tables[cell._id]) {
                            this._tables[cell._id].destroy();
                        }
                        
                        const columns = Object.keys(cell._results[0]).map(key => ({
                            title: key,
                            field: key
                        }));
                        
                        this._tables[cell._id] = new Tabulator('#' + containerId, {
                            data: cell._results,
                            columns: columns,
                            layout: 'fitDataStretch',
                            pagination: true,
                            paginationSize: 50,
                            height: '400px',
                            placeholder: 'Aucune donn√©e'
                        });
                    }
                    
                    this.setStatus('Tableau charg√©', 'success');
                },
                
                async executePlotCell(cell) {
                    if (!cell.query?.trim()) return;
                    
                    // Parser les tables configur√©es (s√©par√©es par des virgules)
                    const tablesConfig = cell.tables || 'source1';
                    const tableNames = tablesConfig.split(',').map(t => t.trim()).filter(t => t);
                    
                    if (tableNames.length === 0) {
                        tableNames.push('source1'); // Fallback par d√©faut
                    }
                    
                    this.setStatus(`Chargement des tables: ${tableNames.join(', ')}...`, 'loading');
                    
                    // Charger uniquement les tables configur√©es
                    const tablesData = await this.loadSpecificTables(tableNames);
                    
                    this.setStatus('Cr√©ation graphique...', 'loading');
                    
                    await this.$nextTick();
                    
                    const containerId = 'plot-' + cell._id;
                    const container = document.getElementById(containerId);
                    
                    if (container) {
                        await PlotlyManager.createPlot(cell.query, tablesData, container);
                    }
                    
                    this.setStatus('Graphique cr√©√©', 'success');
                },
                
                async executeIframeCell(cell) {
                    if (!cell.query?.trim()) return;
                    
                    this.setStatus('Chargement HTML...', 'loading');
                    const results = await DuckDBManager.executeQuery(cell.query);
                    
                    const htmlContent = results.map(row => Object.values(row).join('')).join('\n');
                    
                    await this.$nextTick();
                    
                    const iframe = document.getElementById('iframe-' + cell._id);
                    if (iframe) {
                        const doc = iframe.contentDocument || iframe.contentWindow.document;
                        doc.open();
                        doc.write(htmlContent);
                        doc.close();
                    }
                    
                    this.setStatus('HTML charg√©', 'success');
                },
                
                // Ex√©cuter les lignes √† partir d'un index donn√©
                async runRowsFromIndex(startRowIndex) {
                    for (let rowIndex = startRowIndex; rowIndex < this.rows.length; rowIndex++) {
                        await this.runRow(rowIndex);
                    }
                },
                
                // Ex√©cuter toutes les lignes (ligne par ligne, cellule par cellule de gauche √† droite)
                async runAllRows() {
                    this.isLoading = true;
                    this.setStatus('Ex√©cution de toutes les lignes...', 'loading');
                    
                    // Invalider le cache des tables pour qu'il soit rafra√Æchi
                    this.invalidateTablesCache();
                    
                    for (let rowIndex = 0; rowIndex < this.rows.length; rowIndex++) {
                        await this.runRow(rowIndex);
                    }
                    
                    this.isLoading = false;
                    this.setStatus('Toutes les lignes ex√©cut√©es', 'success');
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // EXPORT / IMPORT
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // THEME TOGGLE
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                toggleTheme() {
                    this.isDarkMode = !this.isDarkMode;
                    if (this.isDarkMode) {
                        document.documentElement.setAttribute('data-theme', 'dark');
                        localStorage.setItem('sqljob-theme', 'dark');
                    } else {
                        document.documentElement.removeAttribute('data-theme');
                        localStorage.setItem('sqljob-theme', 'light');
                    }
                },
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                exportPDF() {
                    window.print();
                },
                
                exportConfig() {
                    try {
                        const config = ConfigManager.buildConfigFromState(this.rows, this.devMode, this.autoExecuteWithoutSources);
                        const jsonString = JSON.stringify(config, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        FileHandler.downloadFile(blob, 'notebook-config.json');
                        this.setStatus('Configuration export√©e', 'success');
                    } catch (error) {
                        this.setStatus('Erreur export: ' + error.message, 'error');
                    }
                },
                
                exportConfigBase64() {
                    try {
                        const config = ConfigManager.buildConfigFromState(this.rows, this.devMode, this.autoExecuteWithoutSources);
                        const jsonString = JSON.stringify(config, null, 2);
                        const base64String = ConfigManager.encodeUTF8ToBase64(jsonString);
                        const blob = new Blob([base64String], { type: 'text/plain' });
                        FileHandler.downloadFile(blob, 'notebook-config.base64.txt');
                        this.setStatus('Configuration export√©e en Base64', 'success');
                    } catch (error) {
                        this.setStatus('Erreur export Base64: ' + error.message, 'error');
                    }
                },
                
                async loadConfig(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        const config = JSON.parse(text);
                        
                        // Helper pour initialiser une cellule
                        const initCell = (cell) => ({
                            ...cell,
                            _id: this.generateCellId(),
                            _status: null,
                            _results: null,
                            _resultInfo: null,
                            sources: cell.type === 'sources' ? (cell.sources || []).map(s => ({
                                ...s,
                                _fileName: '',
                                _currentFile: null,
                                _isDragging: false,
                                _loaded: false
                            })) : undefined
                        });
                        
                        this.rows = (config.job?.rows || []).map((row, rowIndex) => ({
                            _id: this.generateRowId(),
                            style: row.style || '',
                            cells: (row.cells || []).map(cell => initCell(cell))
                        }));
                        
                        this.setStatus('Configuration charg√©e', 'success');
                    } catch (error) {
                        this.setStatus('Erreur import: ' + error.message, 'error');
                    }
                },
                
                async exportHTML() {
                    this.isLoading = true;
                    this.setStatus('G√©n√©ration HTML...', 'loading');
                    
                    try {
                        const config = ConfigManager.buildConfigFromState(this.rows, this.devMode, this.autoExecuteWithoutSources);
                        const jsonString = JSON.stringify(config, null, 2);
                        const configBase64 = ConfigManager.encodeUTF8ToBase64(jsonString);
                        
                        // Mettre √† jour la config base64 dans le DOM
                        document.getElementById('defaultConfigBase64')?.remove();
                        const configScript = document.createElement('script');
                        configScript.type = 'application/octet-stream';
                        configScript.id = 'defaultConfigBase64';
                        configScript.textContent = configBase64;
                        document.head.appendChild(configScript);
                        
                        // Collecter les fichiers des sources depuis toutes les lignes
                        for (const row of this.rows) {
                            for (const cell of row.cells) {
                                if (cell.type === 'sources') {
                                    for (const source of cell.sources) {
                                        if (source._currentFile) {
                                            const safeSourceName = source.name.replace(/[^a-zA-Z0-9_]/g, '_');
                                            
                                            // Supprimer l'ancienne balise
                                            document.querySelectorAll(`script[id^="sourceFile_${safeSourceName}"]`).forEach(s => s.remove());
                                            
                                            // Compresser et encoder le fichier
                                            const arrayBuffer = await source._currentFile.arrayBuffer();
                                            const compressedBuffer = await FileHandler.compressGzip(arrayBuffer);
                                            const fileBase64 = FileHandler.arrayBufferToBase64(compressedBuffer);
                                            
                                            // Cr√©er la balise script
                                            const script = document.createElement('script');
                                            script.type = 'application/octet-stream';
                                            script.id = `sourceFile_${safeSourceName}`;
                                            script.dataset.sourceName = source.name;
                                            script.dataset.fileName = source._fileName;
                                            script.textContent = fileBase64;
                                            document.head.appendChild(script);
                                        }
                                    }
                                }
                            }
                        }
                        
                        // R√©cup√©rer le HTML complet
                        let htmlContent = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
                        htmlContent = htmlContent.replace(/<html[^>]*>/i, '<html lang="fr">');
                        
                        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                        FileHandler.downloadFile(blob, 'index.sqljob.html');
                        
                        this.setStatus('HTML export√©', 'success');
                    } catch (error) {
                        this.setStatus('Erreur export HTML: ' + error.message, 'error');
                    } finally {
                        this.isLoading = false;
                    }
                }
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALISATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        (async function main() {
            // Charger la config depuis le Gist si pr√©sent dans l'URL
            window._loadedConfig = await ConfigManager.loadConfigFromGist();
            
            const container = document.getElementById('app-container');
            if (container) {
                container.innerHTML = generateAppHTML();
            }
            
            window.notebookApp = notebookApp;
            console.log('ü¶Ü sqlJob Notebook initialis√©');
        })();
    </script>
</body>
</html>